-- VHDL Entity Board.FPGA_morse.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:30:36 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FPGA_morse IS
   GENERIC( 
      bitNb : positive := 16
   );
   PORT( 
      RxD       : IN     std_ulogic;
      clock     : IN     std_ulogic;
      reset_N   : IN     std_ulogic;
      RxD_synch : OUT    std_ulogic;
      morseCode : OUT    std_ulogic
   );

-- Declarations

END FPGA_morse ;





-- VHDL Entity Board.inverterIn.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:25:28 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY inverterIn IS
   PORT( 
      in1  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END inverterIn ;





ARCHITECTURE sim OF inverterIn IS
BEGIN

  out1 <= NOT in1;

END ARCHITECTURE sim;





-- VHDL Entity Morse.morseEncoder.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:50:09 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY morseEncoder IS
   GENERIC( 
      clockFrequency : real     := 100.0E6;
      uartBaudRate   : real     := 115.2E3;
      uartDataBitNb  : positive := 8;
      unitDuration   : real     := 100.0E-3;
      toneFrequency  : real     := 300.0
   );
   PORT( 
      morseCode : OUT    std_ulogic;
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      RxD       : IN     std_ulogic
   );

-- Declarations

END morseEncoder ;





-- VHDL Entity Morse.characterRegister.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:20:22 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY characterRegister IS
   GENERIC( 
      characterBitNb : positive := 8
   );
   PORT( 
      charOut   : OUT    std_ulogic_vector (characterBitNb-1 DOWNTO 0);
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      charValid : IN     std_ulogic;
      charIn    : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0)
   );

-- Declarations

END characterRegister ;





ARCHITECTURE RTL OF characterRegister IS
BEGIN

  storeCharacter: process(reset, clock)
  begin
    if reset = '1' then
      charOut <= (others => '0');
    elsif rising_edge(clock) then
      if charValid = '1' then
        charOut <= charIn;
      end if;
    end if;
  end process storeCharacter;

END ARCHITECTURE RTL;




-- VHDL Entity Morse.charToMorse.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:20:22 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY charToMorse IS
   GENERIC( 
      characterBitNb  : positive := 8;
      unitCountDivide : positive := 10E3
   );
   PORT( 
      morseOut  : OUT    std_ulogic;
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      charValid : IN     std_ulogic;
      charIn    : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0)
   );

-- Declarations

END charToMorse ;





-- VHDL Entity Morse.unitCounter.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:20:22 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY unitCounter IS
   GENERIC( 
      unitCountDivide : positive := 10E3;
      unitCountBitNb  : positive := 3
   );
   PORT( 
      clock        : IN     std_ulogic;
      reset        : IN     std_ulogic;
      startCounter : IN     std_ulogic;
      unitNb       : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
      done         : OUT    std_ulogic
   );

-- Declarations

END unitCounter ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




-- library Common;
  use work.CommonLib.all;

ARCHITECTURE RTL OF unitCounter IS

  signal unitCounter: unsigned(requiredBitNb(unitCountDivide)-1 downto 0);
  signal unitCountDone: std_ulogic;
  signal unitNbCounter: unsigned(requiredBitNb(unitCountBitNb)-1 downto 0);
  signal unitNbCountDone: std_ulogic;

BEGIN
                                                       -- count unit base period
  countUnitDuration: process(reset, clock)
  begin
    if reset = '1' then
      unitCounter <= (others => '0');
    elsif rising_edge(clock) then
      if unitCounter = 0 then
        if (startCounter = '1') or (unitNbCounter > 0) then
          unitCounter <= unitCounter + 1;
        end if;
      else
        if unitCountDone = '0' then
          unitCounter <= unitCounter + 1;
        else
          unitCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countUnitDuration;

  unitCountDone <= '1' when unitCounter = unitCountDivide
    else '0';
                                                     -- count unit period number
  countPeriods: process(reset, clock)
  begin
    if reset = '1' then
      unitNbCounter <= (others => '0');
    elsif rising_edge(clock) then
      if unitNbCounter = 0 then
        if startCounter = '1' then
          unitNbCounter <= unitNbCounter + 1;
        end if;
      else
        if unitNbCountDone = '0' then
          if unitCountDone = '1' then
            unitNbCounter <= unitNbCounter + 1;
          end if;
        else
          unitNbCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countPeriods;

  unitNbCountDone <= '1' when (unitNbCounter = unitNb) and (unitCountDone = '1')
    else '0';

  done <= unitNbCountDone;

END ARCHITECTURE RTL;




-- VHDL Entity Morse.charToMorseController.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:20:22 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY charToMorseController IS
   GENERIC( 
      characterBitNb : positive := 8;
      unitCountBitNb : positive := 3
   );
   PORT( 
      morseOut     : OUT    std_ulogic;
      clock        : IN     std_ulogic;
      reset        : IN     std_ulogic;
      charValid    : IN     std_ulogic;
      char         : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
      startCounter : OUT    std_ulogic;
      unitNb       : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
      counterDone  : IN     std_ulogic
   );

-- Declarations

END charToMorseController ;





ARCHITECTURE RTL OF charToMorseController IS
                                                      -- sequence for characters
  type characterStateType is (
    idle, waitReg,
    sA, sB, sC, sD, sE, sF, sG, sH, sI, sJ, sK, sL, sM, sN, sO, sP,
    sQ, sR, sS, sT, sU, sV, sW, sX, sY, sZ,
    s0, s1, s2, s3, s4, s5, s6, s7, s8, s9,
    s2a, s8a, s9a
  );
  signal characterState : characterStateType;
  signal isA, isB, isC, isD, isE, isF, isG, isH,
         isI, isJ, isK, isL, isM, isN, isO, isP,
         isQ, isR, isS, isT, isU, isV, isW, isX,
         isY, isZ,
         is0, is1, is2, is3, is4, is5, is6, is7,
         is8, is9 : std_ulogic;
  signal gotoE, gotoI, gotoS, gotoH, goto5,
         gotoF,
         gotoL, gotoR,
         gotoP,
         gotoN, gotoD, gotoB, goto6,
         gotoC,
         gotoG, gotoZ, goto7,
         goto8,
         goto9,
         gotoT : std_ulogic;
                                                         -- inter-FSM signalling
  signal sendDot, sendDash, sendDotDashDone: std_ulogic;
                                                     -- sequence for morse units
  type sequencerStateType is (
    idle,
    startDot, sendingDot, startDash, sendingDash,
    startSeparator, waitingSeparator,
    dotDashDone
  );
  signal sequencerState : sequencerStateType;

BEGIN
  ------------------------------------------------------------------------------
                                                   -- conditions for morse units
  isA <= '1' when std_match(unsigned(char), "1-0" & x"1") else '0';
  isB <= '1' when std_match(unsigned(char), "1-0" & x"2") else '0';
  isC <= '1' when std_match(unsigned(char), "1-0" & x"3") else '0';
  isD <= '1' when std_match(unsigned(char), "1-0" & x"4") else '0';
  isE <= '1' when std_match(unsigned(char), "1-0" & x"5") else '0';
  isF <= '1' when std_match(unsigned(char), "1-0" & x"6") else '0';
  isG <= '1' when std_match(unsigned(char), "1-0" & x"7") else '0';
  isH <= '1' when std_match(unsigned(char), "1-0" & x"8") else '0';
  isI <= '1' when std_match(unsigned(char), "1-0" & x"9") else '0';
  isJ <= '1' when std_match(unsigned(char), "1-0" & x"A") else '0';
  isK <= '1' when std_match(unsigned(char), "1-0" & x"B") else '0';
  isL <= '1' when std_match(unsigned(char), "1-0" & x"C") else '0';
  isM <= '1' when std_match(unsigned(char), "1-0" & x"D") else '0';
  isN <= '1' when std_match(unsigned(char), "1-0" & x"E") else '0';
  isO <= '1' when std_match(unsigned(char), "1-0" & x"F") else '0';
  isP <= '1' when std_match(unsigned(char), "1-1" & x"0") else '0';
  isQ <= '1' when std_match(unsigned(char), "1-1" & x"1") else '0';
  isR <= '1' when std_match(unsigned(char), "1-1" & x"2") else '0';
  isS <= '1' when std_match(unsigned(char), "1-1" & x"3") else '0';
  isT <= '1' when std_match(unsigned(char), "1-1" & x"4") else '0';
  isU <= '1' when std_match(unsigned(char), "1-1" & x"5") else '0';
  isV <= '1' when std_match(unsigned(char), "1-1" & x"6") else '0';
  isW <= '1' when std_match(unsigned(char), "1-1" & x"7") else '0';
  isX <= '1' when std_match(unsigned(char), "1-1" & x"8") else '0';
  isY <= '1' when std_match(unsigned(char), "1-1" & x"9") else '0';
  isZ <= '1' when std_match(unsigned(char), "1-1" & x"A") else '0';
  is0 <= '1' when std_match(unsigned(char), "011" & x"0") else '0';
  is1 <= '1' when std_match(unsigned(char), "011" & x"1") else '0';
  is2 <= '1' when std_match(unsigned(char), "011" & x"2") else '0';
  is3 <= '1' when std_match(unsigned(char), "011" & x"3") else '0';
  is4 <= '1' when std_match(unsigned(char), "011" & x"4") else '0';
  is5 <= '1' when std_match(unsigned(char), "011" & x"5") else '0';
  is6 <= '1' when std_match(unsigned(char), "011" & x"6") else '0';
  is7 <= '1' when std_match(unsigned(char), "011" & x"7") else '0';
  is8 <= '1' when std_match(unsigned(char), "011" & x"8") else '0';
  is9 <= '1' when std_match(unsigned(char), "011" & x"9") else '0';
  goto5 <= is5;
  gotoH <= ish or goto5 or is4;
  gotoS <= isS or gotoH or isV or is3;
  gotoF <= isF;
  gotoI <= isI or gotoS or isU or gotoF or is2;
  gotoL <= isL;
  gotoR <= isR or gotoL;
  gotoP <= isP;
  gotoE <= isE or gotoI or isA or gotoR or isW or gotoP or isJ or is1;
  goto6 <= is6;
  gotoB <= isB or goto6;
  gotoD <= isD or gotoB or isX;
  gotoC <= isC;
  gotoN <= isN or gotoD or isK or gotoC or isY;
  goto7 <= is7;
  gotoZ <= isZ or goto7;
  gotoG <= isG or gotoZ or isQ;
  goto8 <= is8;
  goto9 <= is9;
  gotoT <= isT or gotoN or isM or gotoG or isO or goto8 or goto9 or is0;
                                                     -- sequence for morse units
  sendCharacterState: process(reset, clock)
  begin
    if reset = '1' then
      characterState <= idle;
    elsif rising_edge(clock) then
      case characterState is
                                                                        -- start
        when idle =>
          if charValid = '1' then
            characterState <= waitReg;
          end if;
        when waitReg =>
          if gotoE = '1' then
            characterState <= sE;
          elsif gotoT = '1' then
            characterState <= sT;
          else
            characterState <= idle;
          end if;
                                                                      -- level 1
        when sE =>
          if sendDotDashDone = '1' then
            if isE = '1' then
              characterState <= idle;
            elsif gotoI = '1' then
              characterState <= sI;
            else
              characterState <= sA;
            end if;
          end if;
        when sT =>
          if sendDotDashDone = '1' then
            if isT = '1' then
              characterState <= idle;
            elsif gotoN = '1' then
              characterState <= sN;
            else
              characterState <= sM;
            end if;
          end if;
                                                                      -- level 2
        when sI =>
          if sendDotDashDone = '1' then
            if isI = '1' then
              characterState <= idle;
            elsif gotoS = '1' then
              characterState <= sS;
            else
              characterState <= sU;
            end if;
          end if;
        when sA =>
          if sendDotDashDone = '1' then
            if isA = '1' then
              characterState <= idle;
            elsif gotoR = '1' then
              characterState <= sR;
            else
              characterState <= sW;
            end if;
          end if;
        when sN =>
          if sendDotDashDone = '1' then
            if isN = '1' then
              characterState <= idle;
            elsif gotoD = '1' then
              characterState <= sD;
            else
              characterState <= sK;
            end if;
          end if;
        when sM =>
          if sendDotDashDone = '1' then
            if isM = '1' then
              characterState <= idle;
            elsif gotoG = '1' then
              characterState <= sG;
            else
              characterState <= sO;
            end if;
          end if;
                                                                     -- level 3a
        when sS =>
          if sendDotDashDone = '1' then
            if isS = '1' then
              characterState <= idle;
            elsif gotoH = '1' then
              characterState <= sH;
            else
              characterState <= sV;
            end if;
          end if;
        when sU =>
          if sendDotDashDone = '1' then
            if isU = '1' then
              characterState <= idle;
            elsif gotoF = '1' then
              characterState <= sF;
            else
              characterState <= s2a;
            end if;
          end if;
        when sR =>
          if sendDotDashDone = '1' then
            if isR = '1' then
              characterState <= idle;
            elsif gotoL = '1' then
              characterState <= sL;
            else
              characterState <= idle;
            end if;
          end if;
        when sW =>
          if sendDotDashDone = '1' then
            if isW = '1' then
              characterState <= idle;
            elsif gotoP = '1' then
              characterState <= sP;
            else
              characterState <= sJ;
            end if;
          end if;
                                                                     -- level 3b
        when sD =>
          if sendDotDashDone = '1' then
            if isD = '1' then
              characterState <= idle;
            elsif gotoB = '1' then
              characterState <= sB;
            else
              characterState <= sX;
            end if;
          end if;
        when sK =>
          if sendDotDashDone = '1' then
            if isK = '1' then
              characterState <= idle;
            elsif gotoC = '1' then
              characterState <= sC;
            else
              characterState <= sY;
            end if;
          end if;
        when sG =>
          if sendDotDashDone = '1' then
            if isG = '1' then
              characterState <= idle;
            elsif gotoZ = '1' then
              characterState <= sZ;
            else
              characterState <= sQ;
            end if;
          end if;
        when sO =>
          if sendDotDashDone = '1' then
            if isO = '1' then
              characterState <= idle;
            elsif goto8 = '1' then
              characterState <= s8a;
            else
              characterState <= s9a;
            end if;
          end if;
                                                                     -- level 4a
        when sH =>
          if sendDotDashDone = '1' then
            if isH = '1' then
              characterState <= idle;
            elsif goto5 = '1' then
              characterState <= s5;
            else
              characterState <= s4;
            end if;
          end if;
        when sV =>
          if sendDotDashDone = '1' then
            if isV = '1' then
              characterState <= idle;
            else
              characterState <= s3;
            end if;
          end if;
        when sF =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;
        when s2a =>
          if sendDotDashDone = '1' then
            characterState <= s2;
          end if;
                                                                     -- level 4b
        when sL =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;
        when sP =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;
        when sJ =>
          if sendDotDashDone = '1' then
            if isJ = '1' then
              characterState <= idle;
            else
              characterState <= s1;
            end if;
          end if;
                                                                     -- level 4c
        when sB =>
          if sendDotDashDone = '1' then
            if isB = '1' then
              characterState <= idle;
            elsif goto6 = '1' then
              characterState <= s6;
            else
              characterState <= idle;
            end if;
          end if;
        when sX =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;
        when sC =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;
        when sY =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;
                                                                     -- level 4d
        when sZ =>
          if sendDotDashDone = '1' then
            if isZ = '1' then
              characterState <= idle;
            elsif goto7 = '1' then
              characterState <= s7;
            else
              characterState <= idle;
            end if;
          end if;
        when sQ =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;
        when s8a =>
          if sendDotDashDone = '1' then
            characterState <= s8;
          end if;
        when s9a =>
          if sendDotDashDone = '1' then
            if goto9 = '1' then
              characterState <= s9;
            else
              characterState <= s0;
            end if;
          end if;
                                                                      -- level 5
        when s5 | s4 | s3 | s2 | s1 | s6 | s7 | s8 | s9 | s0 =>
          if sendDotDashDone = '1' then
            characterState <= idle;
          end if;

        when others => characterState <= idle;
      end case;
    end if;
  end process sendCharacterState;

  sendCharacterOutput: process(characterState)
  begin
    sendDot <= '0';
    sendDash <= '0';
    case characterState is
                                                                      -- level 1
      when sE =>
        sendDot <= '1';
      when sT =>
        sendDash <= '1';
                                                                      -- level 2
      when sI =>
        sendDot <= '1';
      when sA =>
        sendDash <= '1';
      when sN =>
        sendDot <= '1';
      when sM =>
        sendDash <= '1';
                                                                     -- level 3a
      when sS =>
        sendDot <= '1';
      when sU =>
        sendDash <= '1';
      when sR =>
        sendDot <= '1';
      when sW =>
        sendDash <= '1';
                                                                     -- level 3b
      when sD =>
        sendDot <= '1';
      when sK =>
        sendDash <= '1';
      when sG =>
        sendDot <= '1';
      when sO =>
        sendDash <= '1';
                                                                     -- level 4a
      when sH =>
        sendDot <= '1';
      when sV =>
        sendDash <= '1';
      when sF =>
        sendDot <= '1';
      when s2a =>
        sendDash <= '1';
                                                                     -- level 4b
      when sL =>
        sendDot <= '1';
      when sP =>
        sendDot <= '1';
      when sJ =>
        sendDash <= '1';
                                                                     -- level 4c
      when sB =>
        sendDot <= '1';
      when sX =>
        sendDash <= '1';
      when sC =>
        sendDot <= '1';
      when sY =>
        sendDash <= '1';
                                                                     -- level 4d
      when sZ =>
        sendDot <= '1';
      when sQ =>
        sendDash <= '1';
      when s8a =>
        sendDot <= '1';
      when s9a =>
        sendDash <= '1';
                                                                      -- level 5
      when s5 =>
        sendDot <= '1';
      when s4 =>
        sendDash <= '1';
      when s3 =>
        sendDash <= '1';
      when s2 =>
        sendDash <= '1';
      when s1 =>
        sendDash <= '1';
      when s6 =>
        sendDot <= '1';
      when s7 =>
        sendDot <= '1';
      when s8 =>
        sendDot <= '1';
      when s9 =>
        sendDot <= '1';
      when s0 =>
        sendDash <= '1';
      when others => null;
    end case;
  end process sendCharacterOutput;

  ------------------------------------------------------------------------------
                                                     -- sequence for morse units
  sendDotDashState: process(reset, clock)
  begin
    if reset = '1' then
      sequencerState <= idle;
    elsif rising_edge(clock) then
      case sequencerState is
                                                                         -- idle
        when idle =>
          if sendDot = '1' then
            sequencerState <= startDot;
          elsif sendDash = '1' then
            sequencerState <= startDash;
          end if;
                                                                          -- dot
        when startDot =>
          sequencerState <= sendingDot;
        when sendingDot =>
          if counterDone = '1' then
            sequencerState <= startSeparator;
          end if;
                                                                         -- dash
        when startDash =>
          sequencerState <= sendingDash;
        when sendingDash =>
          if counterDone = '1' then
            sequencerState <= startSeparator;
          end if;
                                                                    -- separator
        when startSeparator =>
          sequencerState <= waitingSeparator;
        when waitingSeparator =>
          if counterDone = '1' then
            sequencerState <= dotDashDone;
          end if;
                                                                         -- done
        when dotDashDone =>
          sequencerState <= idle;
      end case;
    end if;
  end process sendDotDashState;

  sendDotDashOutput: process(sequencerState)
  begin
    startCounter <= '0';
    unitNb <= (others => '-');
    sendDotDashDone <= '0';
    morseOut <= '0';
    case sequencerState is
      when startDot | startDash =>
        startCounter <= '1';
        morseOut <= '1';
      when sendingDot =>
        morseOut <= '1';
        unitNb <= to_unsigned(1, unitNb'length);
      when sendingDash =>
        morseOut <= '1';
        unitNb <= to_unsigned(3, unitNb'length);
      when startSeparator =>
        startCounter <= '1';
      when waitingSeparator =>
        unitNb <= to_unsigned(1, unitNb'length);
      when dotDashDone =>
        sendDotDashDone <= '1';
      when others => null;
    end case;
  end process sendDotDashOutput;

END ARCHITECTURE RTL;




--
-- VHDL Architecture Morse.charToMorse.struct
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:20:22 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Morse;

ARCHITECTURE struct OF charToMorse IS

   -- Architecture declarations
   constant unitCountBitNb: positive := 3;

   -- Internal signal declarations
   SIGNAL startCounter : std_ulogic;
   SIGNAL done         : std_ulogic;
   SIGNAL unitNb       : unsigned(unitCountBitNb-1 DOWNTO 0);


   -- Component Declarations
   COMPONENT charToMorseController
   GENERIC (
      characterBitNb : positive := 8;
      unitCountBitNb : positive := 3
   );
   PORT (
      morseOut     : OUT    std_ulogic ;
      clock        : IN     std_ulogic ;
      reset        : IN     std_ulogic ;
      charValid    : IN     std_ulogic ;
      char         : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
      startCounter : OUT    std_ulogic ;
      unitNb       : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
      counterDone  : IN     std_ulogic 
   );
   END COMPONENT;
   COMPONENT unitCounter
   GENERIC (
      unitCountDivide : positive := 10E3;
      unitCountBitNb  : positive := 3
   );
   PORT (
      clock        : IN     std_ulogic ;
      reset        : IN     std_ulogic ;
      startCounter : IN     std_ulogic ;
      unitNb       : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
      done         : OUT    std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
--    FOR ALL : charToMorseController USE ENTITY Morse.charToMorseController;
--    FOR ALL : unitCounter USE ENTITY Morse.unitCounter;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   I_ctl : charToMorseController
      GENERIC MAP (
         characterBitNb => characterBitNb,
         unitCountBitNb => unitCountBitNb
      )
      PORT MAP (
         morseOut     => morseOut,
         clock        => clock,
         reset        => reset,
         charValid    => charValid,
         char         => charIn,
         startCounter => startCounter,
         unitNb       => unitNb,
         counterDone  => done
      );
   I_cnt : unitCounter
      GENERIC MAP (
         unitCountDivide => unitCountDivide,
         unitCountBitNb  => unitCountBitNb
      )
      PORT MAP (
         clock        => clock,
         reset        => reset,
         startCounter => startCounter,
         unitNb       => unitNb,
         done         => done
      );

END struct;




-- VHDL Entity Morse.toneGenerator.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:46:31 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY toneGenerator IS
   GENERIC( 
      toneDivide : positive := 100E3
   );
   PORT( 
      tone  : OUT    std_ulogic;
      clock : IN     std_ulogic;
      reset : IN     std_ulogic
   );

-- Declarations

END toneGenerator ;





-- library Common;
  use work.CommonLib.all;

ARCHITECTURE RTL OF toneGenerator IS

  constant toneCounterBitNb: positive := requiredBitNb(toneDivide-1);
  signal toneCounter: unsigned(toneCounterBitNb-1 downto 0);
  constant toneMin : natural := (2**toneCounterBitNb - toneDivide) / 2;
  constant toneMax : natural := toneMin + toneDivide;

BEGIN

  divide: process(reset, clock)
  begin
    if reset = '1' then
      toneCounter <= to_unsigned(toneMin, toneCounter'length);
    elsif rising_edge(clock) then
      if toneCounter = toneMax then
        toneCounter <= to_unsigned(toneMin, toneCounter'length);
      else
        toneCounter <= toneCounter + 1;
      end if;
    end if;
  end process divide;

  tone <= toneCounter(toneCounter'high);

END ARCHITECTURE RTL;




-- VHDL Entity RS232.serialPortReceiver.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:19:53 23.12.2016
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortReceiver IS
   GENERIC( 
      dataBitNb      : positive := 8;
      baudRateDivide : positive := 2083
   );
   PORT( 
      RxD       : IN     std_ulogic;
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataValid : OUT    std_ulogic
   );

-- Declarations

END serialPortReceiver ;





-- library Common;
  use work.CommonLib.all;

architecture RTL of serialPortReceiver is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide-1)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal rxDelayed: std_uLogic;
  signal dividerCounterSynchronize: std_uLogic;
  signal rxSample: std_uLogic;
  signal rxShiftReg: std_ulogic_vector(dataBitNb-1 downto 0);
  signal rxReceiving: std_uLogic;
  signal rxDataValid: std_uLogic;
  signal rxCounter: unsigned(requiredBitNb(dataBitNb)-1 downto 0);

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterSynchronize = '1' then
        dividerCounter <= to_unsigned(baudRateDivide/2, dividerCounter'length);
      elsif dividerCounterReset = '1' then
        dividerCounter <= (others => '0');
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter)
  begin
    if dividerCounter = baudRateDivide-1 then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  delayRx: process(reset, clock)
  begin
    if reset = '1' then
      rxDelayed <= '0';
    elsif rising_edge(clock) then
      rxDelayed <= RxD;
    end if;
  end process delayRx;

  rxSynchronize: process(RxD, rxDelayed)
  begin
    if RxD /= rxDelayed then
      dividerCounterSynchronize <= '1';
    else
      dividerCounterSynchronize <= '0';
    end if;
  end process rxSynchronize;

  rxSample <= dividerCounterReset;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        rxShiftReg(rxShiftReg'high-1 downto 0) <= rxShiftReg(rxShiftReg'high downto 1);
        rxShiftReg(rxShiftReg'high) <= RxD;
      end if;
    end if;
  end process shiftReg;

  detectReceive: process(reset, clock)
  begin
    if reset = '1' then
      rxReceiving <= '0';
      rxDataValid <= '0';
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxCounter = dataBitNb-1 then
          rxDataValid <= '1';
        elsif RxD = '0' then
          rxReceiving <= '1';
        end if;
      elsif rxDataValid = '1' then
        rxReceiving <= '0';
        rxDataValid <= '0';
      end if;
    end if;
  end process detectReceive;

  countRxBitNb: process(reset, clock)
  begin
    if reset = '1' then
      rxCounter <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxReceiving = '1' then
          rxCounter <= rxCounter + 1;
        else
          rxCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countRxBitNb;

  dataOut <= rxShiftReg;
  dataValid <= rxDataValid;

end RTL;





--
-- VHDL Architecture Morse.morseEncoder.struct
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:50:09 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Morse;
-- LIBRARY RS232;

ARCHITECTURE struct OF morseEncoder IS

   -- Architecture declarations
   --constant : positive := 7;

   -- Internal signal declarations
   SIGNAL characterIn    : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
   SIGNAL characterReg   : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
   SIGNAL characterValid : std_ulogic;
   SIGNAL morseOut       : std_ulogic;
   SIGNAL tone           : std_ulogic;


   -- Component Declarations
   COMPONENT charToMorse
   GENERIC (
      characterBitNb  : positive := 8;
      unitCountDivide : positive := 10E3
   );
   PORT (
      morseOut  : OUT    std_ulogic ;
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      charValid : IN     std_ulogic ;
      charIn    : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT characterRegister
   GENERIC (
      characterBitNb : positive := 8
   );
   PORT (
      charOut   : OUT    std_ulogic_vector (characterBitNb-1 DOWNTO 0);
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      charValid : IN     std_ulogic ;
      charIn    : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT toneGenerator
   GENERIC (
      toneDivide : positive := 100E3
   );
   PORT (
      tone  : OUT    std_ulogic ;
      clock : IN     std_ulogic ;
      reset : IN     std_ulogic 
   );
   END COMPONENT;
   COMPONENT serialPortReceiver
   GENERIC (
      dataBitNb      : positive := 8;
      baudRateDivide : positive := 2083
   );
   PORT (
      RxD       : IN     std_ulogic ;
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataValid : OUT    std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
--    FOR ALL : charToMorse USE ENTITY Morse.charToMorse;
--    FOR ALL : characterRegister USE ENTITY Morse.characterRegister;
--    FOR ALL : serialPortReceiver USE ENTITY RS232.serialPortReceiver;
--    FOR ALL : toneGenerator USE ENTITY Morse.toneGenerator;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 eb1
   morseCode <= morseOut and tone;


   -- Instance port mappings.
   I_enc : charToMorse
      GENERIC MAP (
         characterBitNb  => uartDataBitNb,
         unitCountDivide => integer(clockFrequency*unitDuration + 0.5)
      )
      PORT MAP (
         morseOut  => morseOut,
         clock     => clock,
         reset     => reset,
         charValid => characterValid,
         charIn    => characterReg
      );
   I_char : characterRegister
      GENERIC MAP (
         characterBitNb => uartDataBitNb
      )
      PORT MAP (
         charOut   => characterReg,
         clock     => clock,
         reset     => reset,
         charValid => characterValid,
         charIn    => characterIn
      );
   I_tone : toneGenerator
      GENERIC MAP (
         toneDivide => integer(clockFrequency/toneFrequency + 0.5)
      )
      PORT MAP (
         tone  => tone,
         clock => clock,
         reset => reset
      );
   I_UART : serialPortReceiver
      GENERIC MAP (
         dataBitNb      => uartDataBitNb,
         baudRateDivide => integer(clockFrequency/uartBaudRate + 0.5)
      )
      PORT MAP (
         RxD       => RxD,
         clock     => clock,
         reset     => reset,
         dataOut   => characterIn,
         dataValid => characterValid
      );

END struct;




-- VHDL Entity Board.DFF.symbol
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 11:25:28 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY DFF IS
   PORT( 
      CLK : IN     std_uLogic;
      CLR : IN     std_uLogic;
      D   : IN     std_uLogic;
      Q   : OUT    std_uLogic
   );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0';
    elsif rising_edge(clk) then
      q <= d;
    end if;
  end process;

END ARCHITECTURE sim;





--
-- VHDL Architecture Board.FPGA_morse.struct
--
-- Created:
--          by - francois.UNKNOWN (WE3673)
--          at - 12:55:15 27.04.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Board;
-- LIBRARY Morse;

ARCHITECTURE struct OF FPGA_morse IS

   -- Architecture declarations
   constant clockFrequency: real := 66.0E6;
   constant uartBaudRate: real := 9.6E3;
   constant uartDataBitNb: positive := 7;
   constant morseUnitDuration: real := 100.0E-3;  -- 1/2 * 10 Hz
   constant morseToneFrequency: real := 880.0;

   -- Internal signal declarations
   SIGNAL logic1      : std_uLogic;
   SIGNAL reset       : std_ulogic;
   SIGNAL resetSnch_N : std_ulogic;
   SIGNAL resetSynch  : std_ulogic;

   -- Implicit buffer signal declarations
   SIGNAL RxD_synch_internal : std_ulogic;


   -- Component Declarations
   COMPONENT DFF
   PORT (
      CLK : IN     std_uLogic ;
      CLR : IN     std_uLogic ;
      D   : IN     std_uLogic ;
      Q   : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT inverterIn
   PORT (
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT morseEncoder
   GENERIC (
      clockFrequency : real     := 100.0E6;
      uartBaudRate   : real     := 115.2E3;
      uartDataBitNb  : positive := 8;
      unitDuration   : real     := 100.0E-3;
      toneFrequency  : real     := 300.0
   );
   PORT (
      morseCode : OUT    std_ulogic ;
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      RxD       : IN     std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
--    FOR ALL : DFF USE ENTITY Board.DFF;
--    FOR ALL : inverterIn USE ENTITY Board.inverterIn;
--    FOR ALL : morseEncoder USE ENTITY Morse.morseEncoder;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 4 eb4
   logic1 <= '1';


   -- Instance port mappings.
   I6 : DFF
      PORT MAP (
         CLK => clock,
         CLR => reset,
         D   => logic1,
         Q   => resetSnch_N
      );
   I7 : DFF
      PORT MAP (
         CLK => clock,
         CLR => resetSynch,
         D   => RxD,
         Q   => RxD_synch_internal
      );
   I0 : inverterIn
      PORT MAP (
         in1  => resetSnch_N,
         out1 => resetSynch
      );
   I1 : inverterIn
      PORT MAP (
         in1  => reset_N,
         out1 => reset
      );
   I2 : morseEncoder
      GENERIC MAP (
         clockFrequency => clockFrequency,
         uartBaudRate   => uartBaudRate,
         uartDataBitNb  => uartDataBitNb,
         unitDuration   => morseUnitDuration,
         toneFrequency  => morseToneFrequency
      )
      PORT MAP (
         morseCode => morseCode,
         clock     => clock,
         reset     => resetSynch,
         RxD       => RxD_synch_internal
      );

   -- Implicit buffered output assignments
   RxD_synch <= RxD_synch_internal;

END struct;




